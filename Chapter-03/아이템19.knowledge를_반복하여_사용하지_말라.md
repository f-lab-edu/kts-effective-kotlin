“프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다.”

### knowledge

knowledge는 넓은 의미로 ‘의도적인 정보’를 뜻하며 코드 데이터로 표현할 수 있다.

또한 기본 동작을 하게 아예 코드와 데이터를 부족하게 만들어서도 표현할 수 있다.

예) 상속을 하는데도 불구하고 특정 메서드를 오버라이드하지 않게 강제한다는 것은 해당 메서드가 슈퍼 클래스와 동일하게 동작하기 원한다는 의미이다.

프로젝트를 진행할 때 정의한 모든 것이 knowledge이며

알고리즘의 작동 방식, UI의 형태, 원하는 결과 등 모든 의도적인 정보를 말한다.

우리 프로그램에서 중요한 knowledge를 크게 두 가지 뽑는다면 다음과 같다.

1. 로직(logic) : 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지
2. 공통 알고리즘(common algorithm) : 원하는 동작을 하기 위한 알고리즘

둘의 차이점은 시간에 따른 변화이다.

비즈니스 로직은 시간이 지나면 변하지만, 공통 알고리즘은 한 번 정의된 이후에는 크게 변하지 않는다.

### 모든 것은 변화한다.

프로그래밍에서 유일하게 유지되는 것은 ‘변화한다는 속성’이라는 말이 있다.

우리의 프로젝트의 knowledge도 계속해서 변화하는데 다음과 같은 이유가 있다.

- 회사가 사용자의 요구 또는 습관을 더 많이 알게 되었다.
- 디자인 표준이 변화했다.
- 플랫폼, 라이브러리, 도구 등이 변화해서 이에 대응해야 한다.

모든 것은 변화하고, 우리는 이에 대비해야하는데 변화에서 가장 큰 적은 반복되는 knowledge이다.

여러 부분에 반복되어 있는 코드를 변경하려면 어떻게 해야할까?

가장 간단하게는 반복된 부분을 모두 찾고, 모두 변경하면 되지만 이러한 과정에서 검색 중 실수가 발생할 수 있고 무엇보다 귀찮다는 점이 있다.

`모든 반복되는 곳을 찾아 동일하게 Sync를 맞춘다는 것은 매우 어려운 일이다.`

knowlede의 반복은 프로젝트의 확장성(scalable)을 막고 쉽게 깨지게(fragile)만든다.

다행히도 knowledge의 반복을 줄일 수 있도록 여러 도구와 기능들이 존재한다.

예로 대부분의 플랫폼에서는 사용자 정의 스타일 기능을 통해 한번에 전체적인 뷰와 컴포넌트 디자인을 변경할 수 있다.

또한 SQL을 직접 장성하지 않고 하이버네이트(hibernate)와 같은 ORM(Object Relational Mapping), 익스포즈드(Exposed)와 같은 DAO(Data Access Object)를 활용할 수 있다.

### 언제 코드를 반복해도 될까?

반대로 추출을 통해 knowledge를 줄이면 안되는 상황이 존재한다.

얼핏보면 knowledge 반복처럼 보이지만, 실질적으로 다른 knowledge를 나타내는 부분은 추출하면 안 되는 부분이다.

어떤 프로젝트에서 독립적인 2개의 안드로이드 애플리케이션을 만들고 있을 때

빌드 도구 설정이 비슷할 것이므로 이를 추출해서 knowledge를 줄일 수 있다고 생각할 수 있지만 두 애플리케이션은 독립적이므로 일부 구성이 다를 수 있다.

신중하지 못한 추출은 변경을 더 어렵게 만들 수 있다.

두 코드가 같은 knowledge를 나타내는지, 다른 knowledge를 나타내는지는 
“함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가?” 라는 질문으로 어느정도 결정할 수 있다.

코드를 추출하는 이유는 변경을 쉽게 만들기 위함이므로, 이 질무은 가장 근본적인 질문 이라고 할 수 있다.

한 가지 유용한 휴리스틱으로, 비즈니스 규칙이 다른 곳에서 왔는지 확인하는 방법이 있다.

다른 곳에서 왔다면, 독립적으로 변경될 가능성이 높다.

잘못된 코드 추출로부터 우리를 보호할 수 있는 규칙이 존재하는데

`단일 책임 원칙(Single Responsibility Princile, SRP)`이다.

### 단일 책임 원칙

코드를 추출해도 되는지를 확인할 수 있는 원칙으로 단일 책임 원칙이 있다.

단일 책임 원칙이란 ‘클래스를 변경하는 이유는 단 한가지여야 한다.’라는 의미 이다.

두 액터(actor)가 같은 클래스를 변경하는 일은 없어야한다.

액터란 변화를 만들어내는 존재를 말하며 서로의 업무와 분야에 대해 잘 모르는 개발자들로 비유된다.

이러한 개발자들이 같은 코드를 변경하는 것은 굉장히 위험한 일이다.

어떤 대학에서 Student라는 클래스를 가지고 있을 때

이 클래스는 장학금과 관련된 부서와 인증과 관련된 부서에서 모두 사용된다.

두 부서에서는 Student라는 클래스에 대해서 다음과 같은 두 가지 프로퍼티를 추가했다.

- qualifiesForScholarship : 장학금 관련 부서에서 만든 프로퍼티로, 학생이 장학금을 받을 수 있는 포인트를 갖고 있는지 나타낸다.
- isPassing : 인증 관련 부서에서 만든 프로퍼티로, 학생이 인증을 통과했는지를 나타낸다.

이 두 프로퍼티는 학생의 이전 학기 성적을 기반으로 계산이되어

개발자는 두 프로퍼티를 한꺼번에 계산하는 calculatePointsFromPassedCourses함수를 만들었다.

```kotlin
class Student {
	// ...
	fun isPassing(): Boolean =
			calculatePointsFromPassedCourses() > 15

	fun qualifiesForScholarship(): Boolean =
			calculatePointsFromPassedCourses() > 30

	private fun calculatePointsFromPassedCourses(): Int {
			...
	}
}
```

그런데 “덜 중요한 과목은 장학금 포인트를 줄여달라”라는 새로운 요구사항에 의해 규칙을 바꿔야하는 상황이 생겨 파견된 다른 개발자가 이를 변경하기 위해 qualifiesForScholarship프로퍼티를 확인하고, calculatePointsFromPassedCourses() 메소드를 수정한 후

isPassing도 비슷한 프로퍼티라고 생각해 이와 관련된 동작까지 수정하면 인증을 통과할 줄 알았던 학생이 통과하지 못하게 될 수 있다.

개발자는 함수가 활용되고 있는 다른 부분들도 확인을 했을 것이지만 함수가 자신이 해야하는 일 이외의 책임을 갖고 있을거라는 것은 예측하지 못할 수 있다.

일반적으로 private 함수는 두 가지 이상의 역할을 하지 않기 때문에, 이러한 관습에 따라 생각했을 것이기 때문이다.

책임에 따라 StudentsIsPassingValidator와 StudentQualifiesForScholarshipValidator를 구분해서 만들었다면

혹은 코틀린의 확장 함수를 활용하면 두 함수는 Student 클래스 아래에 두면서도, 각각의 부서가 관리하는 서로 다른 모듈 파일에 배치할 수도 있을 것이다.

```kotlin
// accreditations 모듈
fun Student.qualifiesForScholarship(): Boolean {
	...
}

// scholarship 모듈
fun Student.calculatePointsFromPassedCourses(): Boolean {
	...
}
```

헬퍼 함수는 private 함수로 만들지 않고, 다음과 같이 만드는 것이 일반적이다.

1. 두 부서에서 모두 사용하는 일반적인 public 함수로 헬퍼 함수를 만든다. 공통 부분은 두 부서에서 모두 사용하므로, 이를 함부로 수정해서는 안되게 규약을 정한다.
2. 헬퍼 함수를 각각의 부서 모듈에 따라 2개를 만든다.

단일 책임 원칙은 우리에게 두 가지 사실을 알려준다.

- 서로 다른 곳(위의 예에서는 서로 다른 부서)에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많다. 따라서 비슷한 처리를 하더라도, 완전히 다른 knowledge로 취급하는 것이 좋다.
- 다른 knowledge는 분리해 두는 것이 좋다. 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.

### 정리

모든 것은 변화한다. 따라서 공통 knowledge가 있다면, 이를 추출해서 변화에 대비해야 한다.

여러 요소에 비슷한 부분이 있는 경우, 변경이 필요할 때 실수가 발생할 수 있는데 이러한 부분은 추출하는 것이 좋다.

의도하지 않은 수정을 피하려면 또는 다른 곳에서 조작하는 부분이 있따면, 분리해서 사용하는 것이 좋다.

개발자는 ‘Don’t Repeat Yourself’라는 문장을 엄격하게 지키려고 비슷해 보이는 코드는 모두 추출하려는 경향이 있는데 극단적인 것은 언제나 좋지 않다.

정보 시스템 설계는 예술의 영역과 비슷하기 때문에 수많은 시간과 연습이 필요하다.
